user  www www;

worker_processes auto;

error_log  /home/wwwlogs/nginx_error.log  crit;

pid        /usr/local/nginx/logs/nginx.pid;

#Specifies the value for maximum file descriptors that can be opened by this process.
worker_rlimit_nofile 51200;

#上面配置解释和优化
# user 和 pid 应该按照默认值配置，一般不更改这些配置，因为更改与否没有不同
# worker_processes 定义了nginx对外提供web服务时的worker进程数。最优值取决于许多因素，包括（但不限于）CPU核的数量、存储数据的硬盘数量及负载模式。不能确定时，将其设置为可用的CPU内核数（默认为1）（设置为auto将尝试自动检测它）
# worker_rlimit_nofile 更改worker进程的最大打开文件数限制。如果没有设置，这个值为操作系统的限制。设置后操作系统和nginx可以处理比‘ulimit-a’更多的文件，所以把这个值设高，这样nginx就不会有‘too many open files’的问题了
# error_log 告诉nginx只能记录严重的错误

events
    {
        use epoll;
        worker_connections 51200;
        multi_accept on;
    }

# events模块解释和优化
# use 设置用于复用客户端线程的轮训方法，如果用的Linux 2.6+ ，应该使用 epoll，如果使用*BSD,应该使用kqueue（值得注意：如果不知道nginx该使用哪种轮训方法，它会选择一种最适合你操作系统的）
# worker_connections 设置可由一个worker进程同时打开的最大连接数。如果设置了上面提到的worker_rlimit_nofile，可由将这个值设的很高
# multi_accept 告诉nginx收到一个新连接通知后，接受尽可能多的连接


http
    {
        include       mime.types;
        default_type  application/octet-stream;

        server_names_hash_bucket_size 128;
        client_header_buffer_size 32k;
        large_client_header_buffers 4 32k;
        client_max_body_size 50m;

        #sendfile 可以让sendfile()发挥作用。sendfile()可以在磁盘和TCP socket之间互相拷贝数据(或任意两个文件描述符)。Pre-sendfile是传送数据之前在用户空间申请数据缓冲区。之后用read()将数据从文件拷贝到这个缓冲区，write()将缓冲区数据写入网络。sendfile()是立即将数据从磁盘读到OS缓存。因为这种拷贝是在内核完成的，sendfile()要比组合read()和write()以及打开关闭丢弃缓冲更加有效(更多有关于sendfile)。
        sendfile   on;

        # tcp_nopush 告诉nginx在一个数据包里发送所有头文件，而不一个接一个的发送
        tcp_nopush on;

        #给客户端分配keep_alive连接超时时间，服务器将在这个超时时间多厚关闭连接，可以设置低一些（如10），让nginx持续工作时间更长
        keepalive_timeout 60;

        # client_header_timeout 10 和  client_body_timeout 10 设置请求头和请求体(各自)的超时时间。我们也可以把这个设置低些。
        # reset_timedout_connection on  告诉nginx关闭不响应的客户端连接，这将会释放那个客户端所占用的内存空间
        # send_timeout 10 置顶客户端的响应超时时间。这个设置不会用于整个转发器，而是在两次客户端读取操作之间。如果在这段时间内，客户端没有读取任何数据，nginx就会关闭连接

        # tcp_nodelay 告诉nginx不要缓存数据，而是一段一段的发送--当需要及时发送数据时，就应该给应用设置这个属性，这样发送一小块数据信息时就不能立即得到返回值
        tcp_nodelay on;

        fastcgi_connect_timeout 300;
        fastcgi_send_timeout 300;
        fastcgi_read_timeout 300;
        fastcgi_buffer_size 64k;
        fastcgi_buffers 4 64k;
        fastcgi_busy_buffers_size 128k;
        fastcgi_temp_file_write_size 256k;

        gzip on;
        gzip_min_length  1k;
        gzip_buffers     4 16k;
        gzip_http_version 1.1;
        gzip_comp_level 2;
        gzip_types     text/plain application/javascript application/x-javascript text/javascript text/css application/xml application/xml+rss;
        gzip_vary on;
        gzip_proxied   expired no-cache no-store private auth;
        gzip_disable   "MSIE [1-6]\.";

        #limit_conn_zone $binary_remote_addr zone=perip:10m;
        ##If enable limit_conn_zone,add "limit_conn perip 10;" to server section.

        #server_token 并不会让nginx执行的速度更快，但它可以关闭在错误页面中的nginx版本数字，这样对于安全性是有好处的
        server_tokens off;

        #access_log 设置nginx是否将存储访问日志，关闭这个选项可以让读取磁盘IO操作更快
        access_log off;


        log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                                      '$status $body_bytes_sent "$http_referer" '
                                      '"$http_user_agent" "$http_x_forwarded_for"'
                                       '$upstream_addr $upstream_response_time $request_time ';
                    #access_log  logs/access.log  main;



        #设置限制用户连接配置
        limit_conn_zone $binary_remote_addr zone=perip:10m;
        #limit_req_zone  $binary_remote_addr  zone=req_one:10m rate=1r/s;


server
    {
        #listen 80 default_server;
        listen 80;
        #listen [::]:80 default_server ipv6only=on;
        server_name _;
        index index.html index.htm index.php;
        root  /home/wwwroot/default;
        #error_page   404   /404.html;
        # Deny access to PHP files in specific directory
        #location ~ /(wp-content|uploads|wp-includes|images)/.*\.php$ { deny all; }

        include enable-php.conf;


        location /nginx_status
        {
            stub_status on;
            access_log   off;
        }

        location ~ .*\.(gif|jpg|jpeg|png|bmp|swf)$
        {
            expires      30d;
        }

        location ~ .*\.(js|css)?$
        {
            expires      12h;
        }

        location ~ /.well-known {
            allow all;
        }

        location ~ /\.
        {
            deny all;
        }

        access_log  /home/wwwlogs/access.log;
    }
include vhost/*.conf;


}


